<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Portfolio Dashboard</title>
  
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
      color: #e0e0e0;
      padding: 24px;
      min-height: 100vh;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 32px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .header h1 {
      font-size: 32px;
      font-weight: 700;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -0.5px;
    }
    
    .header-controls {
      display: flex;
      gap: 16px;
      align-items: center;
    }
    
    .currency-toggle {
      display: flex;
      background: rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 4px;
      backdrop-filter: blur(10px);
    }
    
    .currency-btn {
      padding: 8px 20px;
      border: none;
      background: transparent;
      color: #e0e0e0;
      cursor: pointer;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.3s ease;
    }
    
    .currency-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
    
    .refresh-btn {
      padding: 10px 24px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.1);
      color: #e0e0e0;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }
    
    .refresh-btn:hover {
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.2);
      transform: translateY(-1px);
    }
    
    .last-update {
      font-size: 13px;
      color: #888;
    }
    
    /* Cards Grid */
    .cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 32px;
    }
    
    .card {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 24px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      border-color: rgba(255,255,255,0.15);
    }
    
    .card-label {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #888;
      margin-bottom: 8px;
      font-weight: 600;
    }
    
    .card-value {
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 8px;
      letter-spacing: -1px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .privacy-toggle {
      cursor: pointer;
      font-size: 20px;
      opacity: 0.5;
      transition: opacity 0.3s ease;
      user-select: none;
    }
    
    .privacy-toggle:hover {
      opacity: 1;
    }
    
    .value-hidden {
      filter: blur(8px);
      user-select: none;
    }
    
    .card-change {
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .positive {
      color: #10b981;
    }
    
    .negative {
      color: #ef4444;
    }
    
    /* Charts Section */
    .charts-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 32px;
    }
    
    .chart-container {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 24px;
      backdrop-filter: blur(10px);
    }
    
    .chart-title {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 20px;
      color: #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .chart-toggle {
      display: flex;
      gap: 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      padding: 4px;
    }
    
    .chart-toggle-btn {
      padding: 6px 16px;
      border: none;
      background: transparent;
      color: #888;
      cursor: pointer;
      border-radius: 6px;
      font-weight: 600;
      font-size: 12px;
      transition: all 0.3s ease;
    }
    
    .chart-toggle-btn.active {
      background: rgba(102, 126, 234, 0.3);
      color: #667eea;
    }
    
    .chart-toggle-btn:hover {
      background: rgba(255,255,255,0.05);
      color: #e0e0e0;
    }
    
    /* Net Exposure Checkbox */
    input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: #667eea;
    }
    
    input[type="checkbox"]:hover {
      opacity: 0.8;
    }
    
    .timeframe-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .timeframe-btn {
      padding: 6px 14px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.05);
      color: #888;
      cursor: pointer;
      border-radius: 6px;
      font-weight: 600;
      font-size: 12px;
      transition: all 0.3s ease;
    }
    
    .timeframe-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-color: transparent;
    }
    
    .timeframe-btn:hover {
      border-color: rgba(255,255,255,0.2);
      color: #e0e0e0;
    }
    
    .chart-stats {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding: 12px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
    }
    
    .chart-stat {
      text-align: center;
    }
    
    .chart-stat-label {
      font-size: 11px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }
    
    .chart-stat-value {
      font-size: 18px;
      font-weight: 700;
    }
    
    .chart-canvas {
      position: relative;
      height: 300px;
    }
    
    /* Positions Table */
    .positions-section {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 24px;
      backdrop-filter: blur(10px);
    }
    
    .section-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 20px;
      color: #e0e0e0;
    }
    
    .table-container {
      overflow-x: auto;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
    }
    
    thead {
      border-bottom: 2px solid rgba(255,255,255,0.1);
    }
    
    th {
      text-align: left;
      padding: 12px 16px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #888;
      font-weight: 700;
    }
    
    td {
      padding: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      font-size: 14px;
    }
    
    tbody tr {
      transition: background 0.2s ease;
    }
    
    tbody tr:hover {
      background: rgba(255,255,255,0.03);
    }
    
    .ticker-cell {
      font-weight: 700;
      color: #667eea;
    }
    
    .position-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .badge-long {
      background: rgba(16, 185, 129, 0.2);
      color: #10b981;
    }
    
    .badge-short {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }
    
    .loading {
      text-align: center;
      padding: 60px;
      font-size: 18px;
      color: #888;
    }
    
    .loading::after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }
    
    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }
    
    /* Responsive */
    @media (max-width: 968px) {
      .charts-section {
        grid-template-columns: 1fr;
      }
      
      .cards-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    @media (max-width: 640px) {
      .cards-grid {
        grid-template-columns: 1fr;
      }
      
      .header {
        flex-direction: column;
        gap: 16px;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>üìä Portfolio Dashboard</h1>
      <div class="header-controls">
        <div class="currency-toggle">
          <button class="currency-btn active" data-currency="USD" onclick="setCurrency('USD')">USD</button>
          <button class="currency-btn" data-currency="THB" onclick="setCurrency('THB')">THB</button>
        </div>
        <button class="refresh-btn" onclick="refreshData()">üîÑ Refresh</button>
      </div>
    </div>
    
    <div class="last-update" id="lastUpdate">Loading...</div>
    
    <!-- Summary Cards -->
    <div class="cards-grid" id="summaryCards">
      <div class="loading">Loading portfolio data</div>
    </div>
    
    <!-- Charts -->
    <div class="charts-section">
      <div class="chart-container">
        <div class="chart-title">
          <span>Asset Allocation</span>
          <div class="chart-toggle">
            <button class="chart-toggle-btn active" onclick="setAllocationMode('type')">By Type</button>
            <button class="chart-toggle-btn" onclick="setAllocationMode('asset')">By Asset</button>
          </div>
        </div>
        <div style="margin-bottom: 12px;">
          <label style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: #888; cursor: pointer;">
            <input type="checkbox" id="netExposureToggle" onchange="toggleNetExposure()" style="cursor: pointer;">
            <span>Show Net Exposure (Long - Short)</span>
          </label>
        </div>
        <div class="chart-canvas">
          <canvas id="allocationChart"></canvas>
        </div>
      </div>
      
      <div class="chart-container">
        <div class="chart-title">
          <span>Portfolio Growth</span>
        </div>
        <div class="timeframe-selector">
          <button class="timeframe-btn" onclick="setTimeframe('3M')">3M</button>
          <button class="timeframe-btn" onclick="setTimeframe('6M')">6M</button>
          <button class="timeframe-btn" onclick="setTimeframe('1Y')">1Y</button>
          <button class="timeframe-btn active" onclick="setTimeframe('ALL')">All</button>
        </div>
        <div class="chart-stats" id="chartStats">
          <div class="chart-stat">
            <div class="chart-stat-label">Period Return</div>
            <div class="chart-stat-value" id="periodReturn">-</div>
          </div>
          <div class="chart-stat">
            <div class="chart-stat-label">Start Value</div>
            <div class="chart-stat-value" id="startValue">-</div>
          </div>
          <div class="chart-stat">
            <div class="chart-stat-label">Current Value</div>
            <div class="chart-stat-value" id="endValue">-</div>
          </div>
        </div>
        <div class="chart-canvas">
          <canvas id="growthChart"></canvas>
        </div>
      </div>
    </div>
    
    <!-- Positions Table -->
    <div class="positions-section">
      <div class="section-title">Current Positions</div>
      <div class="table-container" id="positionsTable">
        <div class="loading">Loading positions</div>
      </div>
    </div>
  </div>
  
  <script>
    // Global state
    let portfolioData = null;
    let currentCurrency = 'USD';
    let allocationChart = null;
    let growthChart = null;
    let allocationMode = 'type'; // 'type' or 'asset'
    let showNetExposure = false; // true = net out long/short, false = gross exposure
    let selectedTimeframe = 'ALL'; // '3M', '6M', '1Y', 'ALL'
    let privacyMode = false; // true = hidden, false = visible
    
    // Format currency
    function formatCurrency(value, currency) {
      const absValue = Math.abs(value);
      if (currency === 'THB') {
        return '‡∏ø' + absValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
      } else {
        return '$' + absValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
      }
    }
    
    // Format currency with privacy option
    function formatCurrencyWithPrivacy(value, currency, hideValue = false) {
      if (hideValue) {
        // Create masked version based on number of digits
        const formatted = formatCurrency(value, currency);
        const masked = formatted.replace(/\d/g, 'X');
        return masked;
      }
      return formatCurrency(value, currency);
    }
    
    // Toggle privacy mode
    function togglePrivacy() {
      privacyMode = !privacyMode;
      renderSummaryCards();
    }
    
    // Format percentage
    function formatPercent(value) {
      return (value >= 0 ? '+' : '') + value.toFixed(2) + '%';
    }
    
    // Set currency
    function setCurrency(currency) {
      currentCurrency = currency;
      document.querySelectorAll('.currency-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.currency === currency);
      });
      renderDashboard();
    }
    
    // Convert value based on currency
    function convertValue(valueUSD) {
      if (currentCurrency === 'THB' && portfolioData) {
        return valueUSD * portfolioData.exchangeRate;
      }
      return valueUSD;
    }
    
    // Render summary cards
    function renderSummaryCards() {
      if (!portfolioData) return;
      
      const exchangeRate = portfolioData.exchangeRate;
      
      // Calculate total value and total invested from positions
      let totalValue = 0;
      let totalInvested = 0;
      let totalGainLoss = 0;
      
      portfolioData.positions.forEach(pos => {
        const posCurrency = pos.currency;
        
        // Determine the asset's native currency (what currency the price is in from Yahoo)
        let priceNativeCurrency = 'USD'; // Default
        if (pos.ticker.endsWith('.BK')) {
          priceNativeCurrency = 'THB';
        } else if (pos.ticker.startsWith('CASH-THB')) {
          priceNativeCurrency = 'THB';
        } else if (pos.ticker.startsWith('CASH-USD')) {
          priceNativeCurrency = 'USD';
        }
        
        // Convert avg cost to display currency
        let displayAvgCost = pos.avgCost;
        if (posCurrency !== currentCurrency) {
          if (posCurrency === 'THB' && currentCurrency === 'USD') {
            displayAvgCost = pos.avgCost / exchangeRate;
          } else if (posCurrency === 'USD' && currentCurrency === 'THB') {
            displayAvgCost = pos.avgCost * exchangeRate;
          }
        }
        
        // Convert current price from native currency to display currency
        let displayCurrentPrice = pos.currentPrice;
        if (priceNativeCurrency !== currentCurrency) {
          if (priceNativeCurrency === 'USD' && currentCurrency === 'THB') {
            displayCurrentPrice = pos.currentPrice * exchangeRate;
          } else if (priceNativeCurrency === 'THB' && currentCurrency === 'USD') {
            displayCurrentPrice = pos.currentPrice / exchangeRate;
          }
        }
        
        // Current value for this position
        const currentValue = displayCurrentPrice * pos.quantity;
        totalValue += currentValue;
        
        // Only count non-cash positions as "invested"
        const assetType = pos.assetType || '';
        const isCashType = assetType.toLowerCase() === 'cash' || assetType.toLowerCase() === 'stablecoin';
        
        if (!isCashType) {
          totalInvested += displayAvgCost * pos.quantity;
        }
        
        // Calculate gain/loss for this position
        // LONG: profit when price goes up ‚Üí (currentPrice - avgCost) * qty
        // SHORT: profit when price goes down ‚Üí (avgCost - currentPrice) * qty
        let posGainLoss;
        if (pos.positionType === 'SHORT') {
          posGainLoss = (displayAvgCost - displayCurrentPrice) * pos.quantity;
        } else {
          posGainLoss = (displayCurrentPrice - displayAvgCost) * pos.quantity;
        }
        totalGainLoss += posGainLoss;
      });
      
      // Calculate return % as: total gain/loss / total value * 100
      const returnPct = totalValue > 0 ? (totalGainLoss / totalValue) * 100 : 0;
      
      const numPositions = portfolioData.positions.length;
      const isPositive = totalGainLoss >= 0;
      const eyeIcon = privacyMode ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è';
      
      const html = `
        <div class="card">
          <div class="card-label">Total Value</div>
          <div class="card-value">
            <span class="${privacyMode ? 'value-hidden' : ''}">${formatCurrency(totalValue, currentCurrency)}</span>
            <span class="privacy-toggle" onclick="togglePrivacy()" title="${privacyMode ? 'Show values' : 'Hide values'}">${eyeIcon}</span>
          </div>
          <div class="card-change" style="color: #888;">Current Portfolio Value</div>
        </div>
        
        <div class="card">
          <div class="card-label">Total Invested</div>
          <div class="card-value">
            <span class="${privacyMode ? 'value-hidden' : ''}">${formatCurrency(totalInvested, currentCurrency)}</span>
            <span class="privacy-toggle" onclick="togglePrivacy()" title="${privacyMode ? 'Show values' : 'Hide values'}">${eyeIcon}</span>
          </div>
          <div class="card-change" style="color: #888;">Excl. Cash & Stablecoins</div>
        </div>
        
        <div class="card">
          <div class="card-label">Total Return</div>
          <div class="card-value ${isPositive ? 'positive' : 'negative'}">
            <span class="${privacyMode ? 'value-hidden' : ''}">${formatCurrency(totalGainLoss, currentCurrency)}</span>
            <span class="privacy-toggle" onclick="togglePrivacy()" title="${privacyMode ? 'Show values' : 'Hide values'}">${eyeIcon}</span>
          </div>
          <div class="card-change ${isPositive ? 'positive' : 'negative'}">
            <span class="${privacyMode ? 'value-hidden' : ''}">${isPositive ? '+' : ''}${returnPct.toFixed(2)}%</span>
          </div>
        </div>
        
        <div class="card">
          <div class="card-label">Positions</div>
          <div class="card-value">${numPositions}</div>
          <div class="card-change" style="color: #888;">Active Holdings</div>
        </div>
      `;
      
      document.getElementById('summaryCards').innerHTML = html;
    }
    
    // Set allocation mode
    function setAllocationMode(mode) {
      allocationMode = mode;
      
      // Update button states
      document.querySelectorAll('.chart-toggle-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
      
      renderAllocationChart();
    }
    
    // Toggle net exposure
    function toggleNetExposure() {
      showNetExposure = document.getElementById('netExposureToggle').checked;
      renderAllocationChart();
    }
    
    // Render allocation chart
    function renderAllocationChart() {
      if (!portfolioData) return;
      
      const ctx = document.getElementById('allocationChart').getContext('2d');
      const exchangeRate = portfolioData.exchangeRate;
      
      let labels, data;
      
      // STEP 1: Calculate net exposure if checkbox is enabled
      let processedPositions = [];
      let totalHedgedValue = 0; // Track total hedged (offset) value
      
      if (showNetExposure) {
        // Net out positions by ticker first
        const netPositionsMap = {};
        
        portfolioData.positions.forEach(pos => {
          const ticker = pos.ticker;
          const assetName = pos.assetName || ticker;
          const assetType = pos.assetType || 'Other';
          const posCurrency = pos.currency;
          const positionType = pos.positionType;
          
          // Determine the asset's native currency
          let priceNativeCurrency = 'USD';
          if (pos.ticker.endsWith('.BK')) {
            priceNativeCurrency = 'THB';
          } else if (pos.ticker.startsWith('CASH-THB')) {
            priceNativeCurrency = 'THB';
          } else if (pos.ticker.startsWith('CASH-USD')) {
            priceNativeCurrency = 'USD';
          }
          
          // Convert current price from native currency to display currency
          let displayCurrentPrice = pos.currentPrice;
          if (priceNativeCurrency !== currentCurrency) {
            if (priceNativeCurrency === 'USD' && currentCurrency === 'THB') {
              displayCurrentPrice = pos.currentPrice * exchangeRate;
            } else if (priceNativeCurrency === 'THB' && currentCurrency === 'USD') {
              displayCurrentPrice = pos.currentPrice / exchangeRate;
            }
          }
          
          // Initialize if not exists
          if (!netPositionsMap[ticker]) {
            netPositionsMap[ticker] = {
              ticker: ticker,
              assetName: assetName,
              assetType: assetType,
              longQty: 0,
              shortQty: 0,
              price: displayCurrentPrice,
              currency: posCurrency
            };
          }
          
          // Accumulate quantities by position type
          if (positionType === 'LONG') {
            netPositionsMap[ticker].longQty += pos.quantity;
          } else if (positionType === 'SHORT') {
            netPositionsMap[ticker].shortQty += pos.quantity;
          }
        });
        
        // Calculate net positions and hedged amounts
        for (const ticker in netPositionsMap) {
          const net = netPositionsMap[ticker];
          const netQty = net.longQty - net.shortQty;
          
          // Calculate hedged portion (the offset amount)
          const hedgedQty = Math.min(net.longQty, net.shortQty);
          const hedgedValue = hedgedQty * net.price;
          totalHedgedValue += hedgedValue;
          
          // Only include positions with non-zero net exposure
          if (Math.abs(netQty) > 0.0001) {
            processedPositions.push({
              ticker: net.ticker,
              assetName: net.assetName,
              assetType: net.assetType,
              netQuantity: netQty,
              currentPrice: net.price,
              currentValue: Math.abs(netQty) * net.price, // Use absolute value for chart
              isNetLong: netQty > 0,
              currency: net.currency
            });
          }
        }
      } else {
        // Use gross positions (current behavior)
        portfolioData.positions.forEach(pos => {
          const posCurrency = pos.currency;
          
          // Determine the asset's native currency
          let priceNativeCurrency = 'USD';
          if (pos.ticker.endsWith('.BK')) {
            priceNativeCurrency = 'THB';
          } else if (pos.ticker.startsWith('CASH-THB')) {
            priceNativeCurrency = 'THB';
          } else if (pos.ticker.startsWith('CASH-USD')) {
            priceNativeCurrency = 'USD';
          }
          
          // Convert current price from native currency to display currency
          let displayCurrentPrice = pos.currentPrice;
          if (priceNativeCurrency !== currentCurrency) {
            if (priceNativeCurrency === 'USD' && currentCurrency === 'THB') {
              displayCurrentPrice = pos.currentPrice * exchangeRate;
            } else if (priceNativeCurrency === 'THB' && currentCurrency === 'USD') {
              displayCurrentPrice = pos.currentPrice / exchangeRate;
            }
          }
          
          processedPositions.push({
            ticker: pos.ticker,
            assetName: pos.assetName || pos.ticker,
            assetType: pos.assetType || 'Other',
            netQuantity: pos.quantity,
            currentPrice: displayCurrentPrice,
            currentValue: displayCurrentPrice * pos.quantity,
            positionType: pos.positionType,
            currency: pos.currency
          });
        });
      }
      
      // STEP 2: Group by selected mode (type or asset)
      if (allocationMode === 'type') {
        // Group by asset type
        const typeValues = {};
        
        processedPositions.forEach(pos => {
          const assetType = pos.assetType;
          if (!typeValues[assetType]) {
            typeValues[assetType] = 0;
          }
          typeValues[assetType] += pos.currentValue;
        });
        
        labels = Object.keys(typeValues);
        data = labels.map(label => typeValues[label]);
        
        // Add Delta-Hedged category if there's hedged value
        if (showNetExposure && totalHedgedValue > 0.01) {
          labels.push('Delta-Hedged');
          data.push(totalHedgedValue);
        }
        
      } else {
        // Group by asset name (individual positions)
        labels = [];
        data = [];
        
        processedPositions.forEach(pos => {
          let label = pos.assetName;
          
          // Add net position indicator if net exposure mode is enabled
          if (showNetExposure && pos.isNetLong !== undefined) {
            const direction = pos.isNetLong ? 'Long' : 'Short';
            label = `${pos.assetName} (${direction} ${Math.abs(pos.netQuantity).toFixed(4)})`;
          }
          
          labels.push(label);
          data.push(pos.currentValue);
        });
        
        // Add Delta-Hedged category if there's hedged value
        if (showNetExposure && totalHedgedValue > 0.01) {
          labels.push('Delta-Hedged');
          data.push(totalHedgedValue);
        }
      }
      
      const colors = [
        'rgba(102, 126, 234, 0.8)',
        'rgba(118, 75, 162, 0.8)',
        'rgba(237, 100, 166, 0.8)',
        'rgba(255, 154, 158, 0.8)',
        'rgba(16, 185, 129, 0.8)',
        'rgba(59, 130, 246, 0.8)',
        'rgba(245, 158, 11, 0.8)',
        'rgba(139, 92, 246, 0.8)',
        'rgba(236, 72, 153, 0.8)',
        'rgba(20, 184, 166, 0.8)',
      ];
      
      // Use a distinct neutral color for Delta-Hedged category
      const backgroundColors = labels.map((label, index) => {
        if (label === 'Delta-Hedged') {
          return 'rgba(156, 163, 175, 0.6)'; // Gray color for hedged positions
        }
        return colors[index % colors.length];
      });
      
      if (allocationChart) {
        allocationChart.destroy();
      }
      
      allocationChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            data: data,
            backgroundColor: backgroundColors,
            borderColor: 'rgba(15, 12, 41, 0.8)',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              labels: {
                color: '#e0e0e0',
                font: {
                  size: 13,
                  weight: '600'
                },
                padding: 15
              }
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleFont: {
                size: 14,
                weight: '700'
              },
              bodyFont: {
                size: 13
              },
              padding: 12,
              callbacks: {
                label: function(context) {
                  const label = context.label || '';
                  const value = context.parsed;
                  const total = context.dataset.data.reduce((a, b) => a + b, 0);
                  const percentage = ((value / total) * 100).toFixed(1);
                  
                  if (label === 'Delta-Hedged') {
                    return [
                      label + ': ' + formatCurrency(value, currentCurrency) + ' (' + percentage + '%)',
                      '(Offset long/short positions - no directional risk)'
                    ];
                  }
                  
                  return label + ': ' + formatCurrency(value, currentCurrency) + ' (' + percentage + '%)';
                }
              }
            }
          }
        }
      });
    }
    
    // Set timeframe
    function setTimeframe(timeframe) {
      selectedTimeframe = timeframe;
      
      // Update button states
      document.querySelectorAll('.timeframe-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
      
      renderGrowthChart();
    }
    
    // Filter history data by timeframe
    function filterHistoryByTimeframe(history) {
      if (selectedTimeframe === 'ALL') {
        return history;
      }
      
      const now = new Date();
      let cutoffDate;
      
      switch(selectedTimeframe) {
        case '3M':
          cutoffDate = new Date(now.getFullYear(), now.getMonth() - 3, now.getDate());
          break;
        case '6M':
          cutoffDate = new Date(now.getFullYear(), now.getMonth() - 6, now.getDate());
          break;
        case '1Y':
          cutoffDate = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());
          break;
        default:
          return history;
      }
      
      return history.filter(h => {
        const date = new Date(h.timestamp);
        return date >= cutoffDate;
      });
    }
    
    // Render growth chart
    function renderGrowthChart() {
      console.log('üéØ renderGrowthChart() called');
      console.log('   Selected timeframe:', selectedTimeframe);
      console.log('   Current currency:', currentCurrency);
      
      const ctx = document.getElementById('growthChart');
      if (!ctx) {
        console.error('‚ùå ERROR: growthChart canvas element not found!');
        return;
      }
      console.log('‚úÖ Canvas element found');
      
      const context = ctx.getContext('2d');
      
      console.log('üì° Calling getPortfolioHistory()...');
      
      // Get portfolio history data
      google.script.run
        .withSuccessHandler(function(history) {
          console.log('‚úÖ getPortfolioHistory() SUCCESS');
          console.log('   Received history:', history);
          console.log('   History length:', history ? history.length : 'null');
          
          // Destroy existing chart if it exists
          if (growthChart) {
            console.log('üóëÔ∏è Destroying existing chart');
            growthChart.destroy();
          }
          
          // Check if we have any data at all
          if (!history || history.length === 0) {
            console.log('‚ö†Ô∏è No history data - showing placeholder');

          // No data available - show placeholder
          document.getElementById('periodReturn').textContent = '-';
          document.getElementById('startValue').textContent = '-';
          document.getElementById('endValue').textContent = '-';
          
          growthChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: ['No Data'],
              datasets: [{
                label: 'Portfolio Value',
                data: [],
                borderColor: 'rgba(102, 126, 234, 1)',
                backgroundColor: 'rgba(102, 126, 234, 0.1)',
                borderWidth: 3,
                tension: 0.4,
                fill: true
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: { enabled: false }
              },
              scales: {
                y: {
                  grid: { color: 'rgba(255, 255, 255, 0.05)' },
                  ticks: { color: '#888', font: { size: 11 } }
                },
                x: {
                  grid: { display: false },
                  ticks: { color: '#888', font: { size: 11 } }
                }
              }
            }
          });
          
          return;
        }
        
        // Try to filter by timeframe, but if result is empty, use all available data
        console.log('üîç Filtering history by timeframe:', selectedTimeframe);
        let filteredHistory = filterHistoryByTimeframe(history);
        console.log('   After filtering:', filteredHistory.length, 'records');
        
        // If filtering removes all data, just use whatever we have
        if (filteredHistory.length === 0) {
          console.log('‚ö†Ô∏è No data for timeframe ' + selectedTimeframe + ', showing all available data');
          filteredHistory = history;
        }
        
        console.log('üìä Processing', filteredHistory.length, 'records');
        
        // Sort by timestamp (oldest to newest) - PAST ‚Üí PRESENT
        filteredHistory.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        console.log('‚úÖ Sorted by timestamp');
        
        // Create date labels for X-axis
        const labels = filteredHistory.map(h => {
          const date = new Date(h.timestamp);
          return date.toLocaleDateString('en-US', {month: 'short', day: 'numeric'});
        });
        console.log('‚úÖ Created', labels.length, 'date labels');
        
        // Get portfolio values in selected currency
        const values = filteredHistory.map(h => {
          return currentCurrency === 'THB' ? h.valueTHB : h.valueUSD;
        });
        console.log('‚úÖ Extracted values for currency:', currentCurrency);
        console.log('   First value:', values[0]);
        console.log('   Last value:', values[values.length - 1]);
        
        // SIMPLE CALCULATION - Use historical data directly!
        // Start value = first record in the filtered period
        const startValue = values[0];
        
        // Current value = last record in the filtered period
        const currentValue = values[values.length - 1];
        
        // Period return = percentage change from start to current
        const periodReturn = startValue > 0 ? ((currentValue - startValue) / startValue) * 100 : 0;
        const isPositive = periodReturn >= 0;
        
        // Update stats display
        document.getElementById('periodReturn').innerHTML = `<span class="${isPositive ? 'positive' : 'negative'}">${isPositive ? '+' : ''}${periodReturn.toFixed(2)}%</span>`;
        document.getElementById('startValue').textContent = formatCurrency(startValue, currentCurrency);
        document.getElementById('endValue').textContent = formatCurrency(currentValue, currentCurrency);
        
        // Create horizontal reference line at start value
        const startValueLine = Array(values.length).fill(startValue);
        
        console.log('üé® Creating Chart.js chart...');
        
        // Check if Chart.js is loaded
        if (typeof Chart === 'undefined') {
          console.error('‚ùå ERROR: Chart.js library is not loaded!');
          console.error('   Make sure Chart.js script tag is present in HTML');
          return;
        }
        console.log('‚úÖ Chart.js is loaded');
        
        // Check if canvas context is available
        if (!context) {
          console.error('‚ùå ERROR: Cannot get 2D context from canvas');
          return;
        }
        console.log('‚úÖ Canvas context available');
        
        // Render the chart
        try {
          growthChart = new Chart(context, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Portfolio Value',
                data: values,
                borderColor: isPositive ? 'rgba(16, 185, 129, 1)' : 'rgba(239, 68, 68, 1)',
                backgroundColor: isPositive ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)',
                borderWidth: 3,
                tension: 0.4,
                fill: true,
                pointRadius: 4,
                pointHoverRadius: 6,
                pointBackgroundColor: isPositive ? 'rgba(16, 185, 129, 1)' : 'rgba(239, 68, 68, 1)',
                pointBorderColor: '#0f0c29',
                pointBorderWidth: 2
              },
              {
                label: 'Start Value',
                data: startValueLine,
                borderColor: 'rgba(156, 163, 175, 0.4)',
                borderWidth: 2,
                borderDash: [8, 4],
                pointRadius: 0,
                fill: false,
                tension: 0
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleFont: {
                  size: 14,
                  weight: '700'
                },
                bodyFont: {
                  size: 13
                },
                padding: 12,
                callbacks: {
                  label: function(context) {
                    if (context.datasetIndex === 0) {
                      return 'Portfolio: ' + formatCurrency(context.parsed.y, currentCurrency);
                    } else {
                      return 'Start Value: ' + formatCurrency(context.parsed.y, currentCurrency);
                    }
                  }
                }
              }
            },
            scales: {
              y: {
                grid: {
                  color: 'rgba(255, 255, 255, 0.05)'
                },
                ticks: {
                  color: '#888',
                  font: {
                    size: 11
                  },
                  callback: function(value) {
                    return formatCurrency(value, currentCurrency);
                  }
                }
              },
              x: {
                grid: {
                  display: false
                },
                ticks: {
                  color: '#888',
                  font: {
                    size: 11
                  },
                  maxRotation: 45,
                  minRotation: 0
                }
              }
            }
          }
          });
          
          console.log('‚úÖ Chart created successfully!');
          console.log('üìä Chart details:');
          console.log('   Data points:', values.length);
          console.log('   Period Return:', periodReturn.toFixed(2) + '%');
          console.log('   Start Value:', startValue);
          console.log('   Current Value:', currentValue);
          
        } catch (chartError) {
          console.error('‚ùå ERROR creating Chart:');
          console.error('   Error message:', chartError.message);
          console.error('   Error stack:', chartError.stack);
          console.error('   Labels:', labels);
          console.error('   Values:', values);
        }
        
      })
      .withFailureHandler(function(error) {
        console.error('‚ùå ERROR calling getPortfolioHistory():');
        console.error('   Error message:', error.message);
        console.error('   Error stack:', error.stack);
        console.error('   Full error:', error);
        
        // Show error in UI
        document.getElementById('periodReturn').textContent = 'Error';
        document.getElementById('startValue').textContent = '-';
        document.getElementById('endValue').textContent = '-';
      })
      .getPortfolioHistory();
      
      console.log('üì° google.script.run call initiated');
    }
    
    // Render positions table
    function renderPositionsTable() {
      if (!portfolioData || !portfolioData.positions) return;
      
      const positions = portfolioData.positions;
      
      let tableHtml = `
        <table>
          <thead>
            <tr>
              <th>Ticker</th>
              <th>Asset Name</th>
              <th>Type</th>
              <th>Position</th>
              <th>Quantity</th>
              <th>Avg Cost</th>
              <th>Current Price</th>
              <th>Current Value</th>
              <th>Gain/Loss</th>
              <th>Return %</th>
            </tr>
          </thead>
          <tbody>
      `;
      
      positions.forEach(pos => {
        // Convert values to display currency
        const exchangeRate = portfolioData.exchangeRate;
        
        // Position's stored currency (what currency user paid in)
        const posCurrency = pos.currency;
        
        // Determine the asset's native currency (what currency the price is in from Yahoo Finance)
        // Most crypto/US stocks end with -USD, so Yahoo returns USD
        // Thai stocks end with .BK, so Yahoo returns THB
        // Cash positions don't use Yahoo
        let priceNativeCurrency = 'USD'; // Default
        if (pos.ticker.endsWith('.BK')) {
          priceNativeCurrency = 'THB';
        } else if (pos.ticker.startsWith('CASH-THB')) {
          priceNativeCurrency = 'THB';
        } else if (pos.ticker.startsWith('CASH-USD')) {
          priceNativeCurrency = 'USD';
        }
        // For assets ending in -USD, -THB, or other suffixes, parse if needed
        // But most are USD by default
        
        // Convert avg cost to display currency (based on what user paid)
        let displayAvgCost = pos.avgCost;
        if (posCurrency !== currentCurrency) {
          if (posCurrency === 'THB' && currentCurrency === 'USD') {
            displayAvgCost = pos.avgCost / exchangeRate;
          } else if (posCurrency === 'USD' && currentCurrency === 'THB') {
            displayAvgCost = pos.avgCost * exchangeRate;
          }
        }
        
        // Convert current price from native currency to display currency
        let displayCurrentPrice = pos.currentPrice;
        if (priceNativeCurrency !== currentCurrency) {
          if (priceNativeCurrency === 'USD' && currentCurrency === 'THB') {
            // Yahoo gave us USD, we want to display in THB
            displayCurrentPrice = pos.currentPrice * exchangeRate;
          } else if (priceNativeCurrency === 'THB' && currentCurrency === 'USD') {
            // Yahoo gave us THB, we want to display in USD
            displayCurrentPrice = pos.currentPrice / exchangeRate;
          }
        }
        
        // Calculate gain/loss based on position type
        // LONG: profit when price goes up ‚Üí (currentPrice - avgCost) * qty
        // SHORT: profit when price goes down ‚Üí (avgCost - currentPrice) * qty
        let gainLoss;
        if (pos.positionType === 'SHORT') {
          gainLoss = (displayAvgCost - displayCurrentPrice) * pos.quantity;
        } else {
          gainLoss = (displayCurrentPrice - displayAvgCost) * pos.quantity;
        }
        
        // Calculate return %: gain/loss / (avg cost √ó quantity) √ó 100
        const costBasis = displayAvgCost * pos.quantity;
        const returnPct = costBasis > 0 ? (gainLoss / costBasis) * 100 : 0;
        
        const isPositive = gainLoss >= 0;
        
        // Add cash indicator if it's a cash position
        const cashIndicator = pos.isCash ? ' üíµ' : '';
        
        tableHtml += `
          <tr>
            <td class="ticker-cell">${pos.ticker}${cashIndicator}</td>
            <td>${pos.assetName}</td>
            <td>${pos.assetType}</td>
            <td><span class="position-badge ${pos.positionType === 'LONG' ? 'badge-long' : 'badge-short'}">${pos.positionType}</span></td>
            <td>${pos.quantity.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 4})}</td>
            <td>${formatCurrency(displayAvgCost, currentCurrency)}</td>
            <td>${formatCurrency(displayCurrentPrice, currentCurrency)}</td>
            <td>${formatCurrency(displayCurrentPrice * pos.quantity, currentCurrency)}</td>
            <td class="${isPositive ? 'positive' : 'negative'}">${isPositive ? '+' : ''}${formatCurrency(gainLoss, currentCurrency)}</td>
            <td class="${isPositive ? 'positive' : 'negative'}">${isPositive ? '+' : ''}${returnPct.toFixed(2)}%</td>
          </tr>
        `;
      });
      
      tableHtml += `
          </tbody>
        </table>
      `;
      
      document.getElementById('positionsTable').innerHTML = tableHtml;
    }
    
    // Render entire dashboard
    function renderDashboard() {
      if (!portfolioData) return;
      
      renderSummaryCards();
      renderAllocationChart();
      renderGrowthChart();
      renderPositionsTable();
      
      const updateTime = new Date(portfolioData.lastUpdate).toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
      document.getElementById('lastUpdate').textContent = `Last updated: ${updateTime}`;
    }
    
    // Refresh data
    function refreshData() {
      document.getElementById('summaryCards').innerHTML = '<div class="loading">Refreshing data</div>';
      document.getElementById('positionsTable').innerHTML = '<div class="loading">Refreshing positions</div>';
      
      google.script.run.withSuccessHandler(function(data) {
        if (!data) {
          alert('Error: No data returned. Check diagnostics for details.');
          return;
        }
        portfolioData = data;
        renderDashboard();
      }).withFailureHandler(function(error) {
        alert('Error loading data: ' + error.message);
        console.error('Dashboard error:', error);
      }).getPortfolioData();
    }
    
    // Initialize
    window.onload = function() {
      refreshData();
      
      // Auto-refresh every 60 seconds
      setInterval(refreshData, 60000);
    };
  </script>
</body>
</html>